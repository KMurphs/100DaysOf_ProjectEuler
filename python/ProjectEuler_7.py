# By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
# What is the 10 001st prime number?



import math
import time
import random


def isPrime(N):

	N_sqrt = int(math.sqrt(N))
	
	if(N%2==0):
		return False
	
	# prime above 5 are generated by 6k+1 or 6k+5 where k is a natural number greater than 0
	for i in range(3, N_sqrt + 1, 2):
		if(N%i==0):
			return False


	return True

def isPrimeUsing6Increments(N):

	N_sqrt = int(math.sqrt(N))
	
	if(N%2==0):
		return False
	elif(N%3==0):
		return False
	elif(N%5==0):
		return False
	
	# prime above 5 are generated by 6k+1 or 6k+5 where k is a natural number greater than 0
	i = 7
	newk = True
	while i < N_sqrt + 1:
		if(N%i==0):
			return False
		i += 4 if newk else 2
		newk = not newk


	return True

def get_nth_prime_by_brute_force(N, use6Increments=False):

	n = 3 # 1,2,3,5 but the primes are counted from 2 in the problem statement
	k = 1
	newk = True

	
	# prime above 5 are generated by 6k+1 or 6k+5 where k is a natural number greater than 0
	while n < N:
		potential_prime = 6 * k + (1 if newk else 5)
		if(not use6Increments):	
			if(isPrime(potential_prime)):
				n += 1
		else:
			if(isPrimeUsing6Increments(potential_prime)):
				n += 1

		if not newk:
			k += 1
		newk = not newk


	return potential_prime









def test_for_primalityUsingPreviousPrimes(N, previous_primes):

	# print(f"Testing {N} for primality using already found primes: {previous_primes}")
	for i in range(len(previous_primes)):
		if(N%previous_primes[i]==0):
			return False

	return True


def get_nth_prime_by_brute_force_using_previous_primes_and_6_increments(N):

	k = 1
	newk = True
	previous_primes = [2,3,5]
	
	# prime above 5 are generated by 6k+1 or 6k+5 where k is a natural number greater than 0
	while (len(previous_primes)) < N: # 1 is not listed in previous primes and is not counted as prime number in the problem statement
		potential_prime = 6 * k + (1 if newk else 5)
		testResult = test_for_primalityUsingPreviousPrimes(potential_prime, previous_primes)
		# print(f"{potential_prime} is {'' if testResult else 'not'} a prime")
		if(testResult == True):
			previous_primes.append(potential_prime)

		if not newk:
			k += 1
		newk = not newk


	return potential_prime

def get_nth_prime_by_brute_force_using_previous_primes_and_6_increments_v2(N):

	k = 1
	previous_primes = [2,3,5]
	
	# prime above 5 are generated by 6k+1 or 6k+5 where k is a natural number greater than 0
	while (len(previous_primes)) < N: # 1 is not listed in previous primes and is not counted as prime number in the problem statement
		potential_prime_1 = 6 * k + 1
		potential_prime_2 = 6 * k + 5
		# print(f"{potential_prime_1} is {'' if test_for_primalityUsingPreviousPrimes(potential_prime_1, previous_primes) else 'not'} a prime")
		# print(f"{potential_prime_2} is {'' if test_for_primalityUsingPreviousPrimes(potential_prime_2, previous_primes) else 'not'} a prime")
		if(test_for_primalityUsingPreviousPrimes(potential_prime_1, previous_primes) == True):
			previous_primes.append(potential_prime_1)
		if(test_for_primalityUsingPreviousPrimes(potential_prime_2, previous_primes) == True):
			previous_primes.append(potential_prime_2)
		k += 1


	return previous_primes[N-1]







def pifct(x): return x/math.log(x)

def get_nth_prime_using_sieve(N):

	# if pi(x) is the prime counting function (giving the number of prime below x), then its limits when x is huge is
	# x/ln(x)
	# https://en.wikipedia.org/wiki/Prime_number_theorem

	x_bound = 100
	while pifct(x_bound) < N:
		x_bound *= 10
	n_primes_below = int(x_bound)
	# print(f"It is estimated that the prime at position {N} is below {x_bound} (approx. {n_primes_below})")

	prime_count = 0
	sieve = [True] * n_primes_below
	for i in range(2, n_primes_below): # i = 0,1,2,3 maps to prime 1,2,3,5 
		if(sieve[i]):

			prime_count += 1
			if(prime_count == N):
				return i 

			for j in range(i*i, n_primes_below, i):
				sieve[j] = False
	

	return "undefined"






if __name__ == "__main__": 
	N = 10001

	start = time.time()
	print(get_nth_prime_by_brute_force(N))
	end = time.time()
	print(f"Operation took {1000*(end - start):.2f}ms")

	start = time.time()
	print(get_nth_prime_by_brute_force(N, True))
	end = time.time()
	print(f"Operation took {1000*(end - start):.2f}ms")

	start = time.time()
	print(get_nth_prime_by_brute_force_using_previous_primes_and_6_increments_v2(N))
	end = time.time()
	print(f"Operation took {1000*(end - start):.2f}ms")

	start = time.time()
	print(get_nth_prime_using_sieve(N))
	end = time.time()
	print(f"Operation took {1000*(end - start):.2f}ms")

